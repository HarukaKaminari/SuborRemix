#include "SSD1306.h"
#include "I2C.h"
#include <INTRINS.H>
#include <STRING.H>


static u8 xdata VRAM[1024];		// 12864的显存为1K字节
static u16 xdata tmpBuf[0x10];	// 16*2的字模缓冲区


// OLED的地址
#define SSD1306_ADDR		0x3C
//#define SSD1306_ADDR		0x3E

// SSD1306指令集
// 基础指令
#define SSD1306_SET_CONTRAST_CONTROL					0x81
#define SSD1306_DISPLAY_ALL_ON_RESUME					0xA4
#define SSD1306_DISPLAY_ALL_ON							0xA5
#define SSD1306_NORMAL_DISPLAY							0xA6
#define SSD1306_INVERT_DISPLAY							0xA7
#define SSD1306_DISPLAY_OFF								0xAE
#define SSD1306_DISPLAY_ON								0xAF
#define SSD1306_NOP										0xE3
// 卷轴指令
#define SSD1306_HORIZONTAL_SCROLL_RIGHT					0x26
#define SSD1306_HORIZONTAL_SCROLL_LEFT					0x27
#define SSD1306_HORIZONTAL_SCROLL_VERTICAL_AND_RIGHT	0x29
#define SSD1306_HORIZONTAL_SCROLL_VERTICAL_AND_LEFT		0x2A
#define SSD1306_DEACTIVATE_SCROLL						0x2E
#define SSD1306_ACTIVATE_SCROLL							0x2F
#define SSD1306_SET_VERTICAL_SCROLL_AREA				0xA3
// 寻址设置指令
#define SSD1306_SET_LOWER_COLUMN						0x00
#define SSD1306_SET_HIGHER_COLUMN						0x10
#define SSD1306_MEMORY_ADDR_MODE						0x20
#define SSD1306_SET_COLUMN_ADDR							0x21
#define SSD1306_SET_PAGE_ADDR							0x22
// 硬件配置指令
#define SSD1306_SET_START_LINE							0x40
#define SSD1306_SET_SEGMENT_REMAP						0xA0
#define SSD1306_SET_MULTIPLEX_RATIO						0xA8
#define SSD1306_COM_SCAN_DIR_INC						0xC0
#define SSD1306_COM_SCAN_DIR_DEC						0xC8
#define SSD1306_SET_DISPLAY_OFFSET						0xD3
#define SSD1306_SET_COM_PINS							0xDA
#define SSD1306_CHARGE_PUMP								0x8D
// 时序和驱动方案设置指令
#define SSD1306_SET_DISPLAY_CLOCK_DIV_RATIO				0xD5
#define SSD1306_SET_PRECHARGE_PERIOD					0xD9
#define SSD1306_SET_VCOM_DESELECT						0xDB


bit isPageAddressingMode = 0;


static void delay() small{
	u8 x, y;
	for(x=0;x<0xFF;++x){
		for(y=0;y<0xFF;++y){
			_nop_();
		}
	}
}

static void SSD1306_SendCommand(u8 value) small{
	u8 dat;
	I2C_Start();
	dat = 0x00;
	I2C_Puts(SSD1306_ADDR, 0, 0, &dat, sizeof(dat));
	dat = value;
	I2C_Puts(SSD1306_ADDR, 0, 0, &dat, sizeof(dat));
	I2C_Stop();
}

static void SSD1306_SendData(u8 value) small{
	u8 dat;
	I2C_Start();
	dat = 0x40;
	I2C_Puts(SSD1306_ADDR, 0, 0, &dat, sizeof(dat));
	dat = value;
	I2C_Puts(SSD1306_ADDR, 0, 0, &dat, sizeof(dat));
	I2C_Stop();
}

void SSD1306_Init() small{
	// 延迟200ms。这个延迟非常重要，必须要有
	delay();
	SSD1306_SendCommand(SSD1306_DISPLAY_OFF);	// 0xAE
	SSD1306_SendCommand(SSD1306_SET_DISPLAY_CLOCK_DIV_RATIO);	// 0xD5
	SSD1306_SendCommand(0x80);
	SSD1306_SendCommand(SSD1306_SET_MULTIPLEX_RATIO);	// 0xA8
	SSD1306_SendCommand(0x3F);
	SSD1306_SendCommand(SSD1306_SET_DISPLAY_OFFSET);	// 0xD3
	SSD1306_SendCommand(0x0);
	SSD1306_SendCommand(SSD1306_SET_START_LINE | 0x0);	// 0x40
	SSD1306_SendCommand(SSD1306_CHARGE_PUMP);	// 0x8D
	//SSD1306_SendCommand(0x10);	// Vcc supplied Externally
	SSD1306_SendCommand(0x14);	// VCC Generated by Internal DC/DC Circuit
	SSD1306_SendCommand(SSD1306_MEMORY_ADDR_MODE);	// 0x20
	SSD1306_SendCommand(0x00);
	SSD1306_SendCommand(SSD1306_SET_SEGMENT_REMAP | 0x1);	// 0xA0|1=A1
	SSD1306_SendCommand(SSD1306_COM_SCAN_DIR_DEC);	// 0xC8

	SSD1306_SendCommand(SSD1306_SET_COM_PINS);	// 0xDA
	SSD1306_SendCommand(0x12);

	SSD1306_SendCommand(SSD1306_SET_CONTRAST_CONTROL);	// 0x81
	SSD1306_SendCommand(0xCF);	// 9F Vcc Externally /CF Vcc dc_dc
	SSD1306_SendCommand(SSD1306_SET_PRECHARGE_PERIOD);	// 0xD9
	SSD1306_SendCommand(0xF1);	// 0x22 vcc externally // F1 internal dc_dc
	SSD1306_SendCommand(SSD1306_SET_VCOM_DESELECT);	// 0xDB
	SSD1306_SendCommand(0x40);
	SSD1306_SendCommand(SSD1306_DISPLAY_ALL_ON_RESUME);	// 0xA4
	SSD1306_SendCommand(SSD1306_NORMAL_DISPLAY);	// 0xA6
	SSD1306_SendCommand(SSD1306_DISPLAY_ON);	// 0xAF
}

void SSD1306_Refresh() small{
	u8 x = 0;
	u16 y = 0;
	for(y=0;y<8;++y){
		for(x=0;x<128;++x){
			SSD1306_SendData(VRAM[x + (y << 7)]);
		}
	}
}

void SSD1306_Clear() small{
	memset(VRAM, 0, sizeof(VRAM));
}

/*
将字符缓冲区中的字符绘制到VRAM缓冲区
x最小取值为-fontSize，最大取值为127
y最小取值为-fontSize，最大取值为31或63
*/
void SSD1306_DrawChar(u8 fontSize, u16 chr, s8 x, s8 y, bit c) small{
	u8 i;
	s8 page = y >> 3;
    if(x < -fontSize)x = -fontSize;
    if(x > 127)return;
    if(y < -fontSize)y = -fontSize;
	if(y > 63)return;
	
	for(i=0;i<fontSize;++i){
		// 如果水平方向小于0像素则不再进行绘制
		if(x + i < 0)continue;
		// 如果水平方向超过128像素则不再进行绘制
		if(x + i < 128){
			// 获得VRAM偏移量
			s16 vramOffset = x + i + (page << 7);
			// 获得页内偏移量
			u8 offsetInPage = y & 7;
			if(vramOffset >= 0){
				// 写数据
				if(c)
					VRAM[vramOffset] |= (tmpBuf[i] << offsetInPage) & 0xFF;
				else
					VRAM[vramOffset] &= ~(tmpBuf[i] << offsetInPage) & 0xFF;
			}
			// 偏移到下一个页
			vramOffset += 128;
			// 如果垂直方向超过32或64像素则不再进行绘制
			if(vramOffset >= 1024)continue;
			if(vramOffset >= 0){
				if(c)
					VRAM[vramOffset] |= (tmpBuf[i] >> (8 - offsetInPage)) & 0xFF;
				else
					VRAM[vramOffset] &= ~(tmpBuf[i] >> (8 - offsetInPage)) & 0xFF;
			}
			vramOffset += 128;
			// 如果垂直方向超过32或64像素则不再进行绘制
			if(vramOffset >= 1024)continue;
			if(vramOffset >= 0){
				if(c)
					VRAM[vramOffset] |= (tmpBuf[i] >> (16 - offsetInPage)) & 0xFF;
				else
					VRAM[vramOffset] &= ~(tmpBuf[i] >> (16 - offsetInPage)) & 0xFF;
			}
		}
	}
}

void SSD1306_DrawString(u8 fontSize, const char* str, s16 x, s16 y, bit c) small{
	
}

/*
在缓冲区任意位置画点
*/
void SSD1306_DrawPixel(u8 x, u8 y, bit c) small{
	if(x > 127)return;
	if(y > 63)return;
	if(c)
		VRAM[x + (y >> 3 << 7)] |= 1 << (y & 7);
	else
		VRAM[x + (y >> 3 << 7)] &= ~(1 << (y & 7));
}

/*
在缓冲区任意位置画直线
*/
#ifndef ABS
#define ABS(a)	((a) > 0 ? (a) : -(a))
#endif
void SSD1306_DrawLine(u8 x0, u8 y0, u8 x1, u8 y1, bit c) small{
	s8 dx = x1 - x0;
	s8 dy = y1 - y0;
	s8 ux = ((dx > 0) << 1) - 1;	// x的增量方向，正负1
	s8 uy = ((dy > 0) << 1) - 1;	// y的增量方向，正负1
	s8 x = x0, y = y0, eps = 0;		// eps为累加误差

	dx = ABS(dx);
	dy = ABS(dy); 
	if(dx > dy){
		for(;x!=x1;x+=ux){
			SSD1306_DrawPixel(x, y, c);
			eps += dy;
			if((eps << 1) >= dx){
				y += uy;
				eps -= dx;
			}
		}
	}else{
		for(;y!=y1;y+=uy){
			SSD1306_DrawPixel(x, y, c);
			eps += dx;
			if((eps << 1) >= dy){
				x += ux;
				eps -= dy;
			}
		}
	}
}

/*
在缓冲区任意位置填充矩形
*/
void SSD1306_FillRect(u8 x, u8 y, u8 w, u8 h, bit c) small{
	u8 i, j;
	if(x > 127)return;
	if(x + w > 128)w = 128 - x;
	if(y > 63)return;
	if(y + h > 64)h = 64 - y;
	
	for(i=x;i<=x+w-1;++i){
		u8 page0 = y >> 3;
		u8 page1 = (y + h) >> 3;
		u8 _y0 = y & 7;
		u8 _y1 = (y + h - 1) & 7;
		if(page0 == page1){
			u8 mask = 0;
			for(j=_y0;j<=_y1;++j){
				mask |= (1 << j);
			}
			if(c){
				VRAM[i + (page0 << 7)] |= mask;
			}else{
				VRAM[i + (page0 << 7)] &= ~mask;
			}
		}else{
			for(j=page0;j<=page1;++j){
				if(j == page0){
					if(c)
						VRAM[i + (j << 7)] |= (0xFF << _y0);
					else
						VRAM[i + (j << 7)] &= ~(0xFF << _y0);
				}else if(j == page1){
					if(c)
						VRAM[i + (j << 7)] |= (0xFF >> (7 - _y1));
					else
						VRAM[i + (j << 7)] &= ~(0xFF >> (7 - _y1));
				}else{
					if(c)
						VRAM[i + (j << 7)] = 0xFF;
					else
						VRAM[i + (j << 7)] = 0;
				}
			}
		}
	}
}

/*
在缓冲区任意位置画圆
*/
void SSD1306_DrawCircle(u8 x1, u8 y1, u8 r, bit c) small{
	s16 x = 0, y = r;
	s8 d = 1 - r;
	while(y > x){
		SSD1306_DrawPixel(x1 + x, y1 + y, c);
		SSD1306_DrawPixel(x1 + y, y1 + x, c);
		SSD1306_DrawPixel(x1 - x, y1 + y, c);
		SSD1306_DrawPixel(x1 - y, y1 + x, c);
		SSD1306_DrawPixel(x1 - x, y1 - y, c);
		SSD1306_DrawPixel(x1 - y, y1 - x, c);
		SSD1306_DrawPixel(x1 + x, y1 - y, c);
		SSD1306_DrawPixel(x1 + y, y1 - x, c);
		if(d < 0){
			d += 2 * x + 3;
		}else{
			d += 2 * (x - y) + 5;
			y--;
		}
		x++;
	}
}
